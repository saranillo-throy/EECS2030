package PE1;
import java.util.ArrayList;

/* PLEASE DO NOT MODIFY A SINGLE STATEMENT IN THE TEXT BELOW.
READ THE FOLLOWING CAREFULLY AND FILL IN THE GAPS

I hereby declare that all the work that was required to 
solve the following problem including designing the algorithms
and writing the code below, is solely my own and that I received
no help in creating this solution and I have not discussed my solution 
with anybody. I affirm that I have read and understood
the Senate Policy on Academic honesty at 
https://secretariat-policies.info.yorku.ca/policies/academic-honesty-senate-policy-on/
and I am well aware of the seriousness of the matter and the penalties that I will face as a 
result of committing plagiarism in this assignment.

BY FILLING THE GAPS,YOU ARE SIGNING THE ABOVE STATEMENTS.

Full Name: Throy Saranillo
Student Number: 218089730
Course Section: M
*/

public class MinDominantSet {
	int [][] buildings; 
	ArrayList<Integer[]> combination; 
	private int size;
	int index;
	
	public static void main(String[] args) {
		/*
		 * We don't need this method to solve the problem. I kept
	     * it here just in case you need to test your code differently.
		 */
	}
	
	
	public MinDominantSet () {
		combination = new ArrayList<Integer[]>(); 
	}
	
	public MinDominantSet (int size, int [][] buildings) {
		// insert your code here for task 2
		this.size = size;
		this.buildings = buildings;
		combination = new ArrayList<Integer[]>(); 
		
	}
	
	private Integer[] intoArray(int n) {

		// turns n into an array of all integers less than n and stores it in nArray
		Integer[] nArray = new Integer[n];
		
		for (int i = 0; i < n; i ++) {
			nArray[i] = i;
		}
		
		return nArray;
	}
	
	private void combinationHelper(Integer[]inputArr, Integer[] tempArr, int begin, int end, int index, int r) {
		// when index is equal to r print everything
		if (index == r) {
			// make into loop and 
			Integer[] finalCombo = new Integer[r];
			for (int i = 0; i < r; i ++) {
				finalCombo[i] = tempArr[i];
			}
			
			combination.add(finalCombo);
			return;
			
		} else {
			for (int j = begin; j <= end && end -i + 1 >= r; j ++) {
				tempArr[j] = inputArr[j];
				combinationHelper(inputArr, tempArr, j + 1, end, index + 1, r);
			}
		} 
		
	}
	     
	void combination(int n, int r) {
		// insert your code here for task1
		// Note: this method or its helper must be recursive. 
		Integer[] inputArr = intoArray(n);
		Integer[] tempArr = new Integer[r];
		
		combinationHelper(inputArr, tempArr, 0, n - 1, 0, r);
		
	}

	
	public boolean isEnough(int numMachine) {
		// insert your code here for task 3
		// you may want to change the return value
		return true;
	}

	
	/**
	 * This method prints the content of the combination.
	 * we don't need this method to solve this problem, 
	 * however it is there to help you see the content of 
	 * the list, when you check for the correctness of your
	 * code. 
	 */
	void print() {

		for (int i = 0; i < combination.size(); i++) {
			for (int j = 0; j < combination.get(i).length; j++) {
				System.out.print(combination.get(i)[j]+ "\t"); 
			}
			System.out.println(); 		
		}
	}
			 
} // end of MinDominantSet

